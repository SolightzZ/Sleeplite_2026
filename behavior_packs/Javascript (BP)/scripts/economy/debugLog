//  ------------------- DEBUG LOGGING -------------------
function debugLog(...args) {
  try {
    const funcName = (new Error().stack.split("\n")[2] || "").trim().split(" ")[1] || "unknown";
    console.warn(`[${funcName}]`, ...args);
  } catch (e) {
    console.warn("[debugLogError]", ...args, e);
  }
}

import { world, system, Player, ItemStack } from "@minecraft/server";
import { ActionFormData, ModalFormData, MessageFormData } from "@minecraft/server-ui";

const BANK_DB_NAME = "Banking";
const BANK_DISPLAY_NAME = "Banking";
const INTEREST_RATE = 0.03;
const INTEREST_DAYS = 7;
const INTEREST_COOLDOWN_MS = INTEREST_DAYS * 24 * 60 * 60 * 1000;
const DIAMOND_ITEM_ID = "minecraft:diamond";
const BANK_OPEN_ITEM = "addon:bank";

// ===== SCOREBOARD / BALANCE
function getBankObjective() {
  try {
    return world.scoreboard.getObjective(BANK_DB_NAME);
  } catch (e) {
    console.warn("getBankObjective:", e);
    return null;
  }
}

function initializeObjective() {
  try {
    if (!world.scoreboard.getObjective(BANK_DB_NAME)) {
      world.scoreboard.addObjective(BANK_DB_NAME, BANK_DISPLAY_NAME);
    }
  } catch (e) {
    console.warn("initializeObjective:", e);
  }
}

function getScore(key) {
  try {
    return getBankObjective()?.getScore(key) ?? 0;
  } catch (e) {
    console.warn("getScore:", key, e);
    return 0;
  }
}

function setScore(key, value) {
  try {
    getBankObjective()?.setScore(key, Math.floor(value));
  } catch (e) {
    console.warn("setScore:", key, value, e);
  }
}

const getPlayerKey = (player) => {
  try {
    return player instanceof Player ? player.name : String(player);
  } catch (e) {
    console.warn("getPlayerKey:", e);
    return "unknown";
  }
};

const getInterestKey = (player) => {
  try {
    return `+${getPlayerKey(player)}`;
  } catch (e) {
    console.warn("getInterestKey:", e);
    return "+unknown";
  }
};

const getBalance = (player) => {
  try {
    return getScore(getPlayerKey(player));
  } catch (e) {
    console.warn("getBalance:", player?.name, e);
    return 0;
  }
};

const setBalance = (player, value) => {
  try {
    setScore(getPlayerKey(player), value);
  } catch (e) {
    console.warn("setBalance:", player?.name, value, e);
  }
};

function addBalance(player, value) {
  try {
    if (value <= 0) return;
    const current = getBalance(player);
    setScore(getPlayerKey(player), current + value);
  } catch (e) {
    console.warn("addBalance:", player?.name, value, e);
  }
}

function removeBalance(player, value) {
  try {
    const currentBalance = getBalance(player);
    if (currentBalance < value) return 0;
    const newBalance = currentBalance - value;
    setBalance(player, newBalance);
    return newBalance;
  } catch (e) {
    console.warn("removeBalance:", player?.name, value, e);
    return 0;
  }
}

// ===== DATE HELPERS (GMT+7)
function getThailandDate() {
  try {
    const now = new Date();
    return new Date(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate(),
      now.getUTCHours() + 7,
      now.getUTCMinutes(),
      now.getUTCSeconds(),
      now.getUTCMilliseconds()
    );
  } catch (e) {
    console.warn("getThailandDate:", e);
    return new Date();
  }
}

const getDateIntValue = (date) => {
  try {
    const d = date || getThailandDate();
    return parseInt(`${String(d.getDate()).padStart(2, "0")}${String(d.getMonth() + 1).padStart(2, "0")}${d.getFullYear()}`);
  } catch (e) {
    console.warn("getDateIntValue:", e);
    return 1012000;
  }
};

const parseDateIntValue = (value) => {
  try {
    const s = value.toString().padStart(8, "0");
    const day = parseInt(s.substring(0, 2));
    const month = parseInt(s.substring(2, 4)) - 1;
    const year = parseInt(s.substring(4, 8));
    return new Date(year, month, day);
  } catch (e) {
    console.warn("parseDateIntValue:", value, e);
    return getThailandDate();
  }
};

function getDateTime() {
  try {
    const d = getThailandDate();
    return `${String(d.getDate()).padStart(2, "0")}/${String(d.getMonth() + 1).padStart(2, "0")}/${d.getFullYear()} ${String(d.getHours()).padStart(
      2,
      "0"
    )}:${String(d.getMinutes()).padStart(2, "0")}`;
  } catch (e) {
    console.warn("getDateTime:", e);
    return "01/01/2000 00:00";
  }
}

function formatDate(date) {
  try {
    return `${String(date.getDate()).padStart(2, "0")}/${String(date.getMonth() + 1).padStart(2, "0")}/${date.getFullYear()}`;
  } catch (e) {
    console.warn("formatDate:", e);
    return "??/??/????";
  }
}

// ===== INVENTORY LOGIC
function countDiamonds(player) {
  try {
    const inv = player.getComponent("inventory").container;
    let total = 0;
    for (let i = 0; i < inv.size; i++) {
      const stack = inv.getItem(i);
      if (stack?.typeId === DIAMOND_ITEM_ID) {
        total += stack.amount ?? 0;
      }
    }
    return total;
  } catch (e) {
    console.warn("countDiamonds:", player?.name, e);
    return 0;
  }
}

function getEmptySlots(player) {
  try {
    const inv = player.getComponent("inventory").container;
    let empty = 0;
    for (let i = 0; i < inv.size; i++) {
      if (!inv.getItem(i)) empty++;
    }
    return empty;
  } catch (e) {
    console.warn("getEmptySlots:", player?.name, e);
    return 0;
  }
}

function deposit(player, amount) {
  try {
    const inv = player.getComponent("inventory").container;
    let remaining = amount;

    for (let i = 0; i < inv.size && remaining > 0; i++) {
      const stack = inv.getItem(i);
      if (stack?.typeId === DIAMOND_ITEM_ID) {
        const take = Math.min(stack.amount, remaining);
        if (take <= 0) continue;

        remaining -= take;
        const newAmount = stack.amount - take;
        if (newAmount > 0) {
          stack.amount = newAmount;
          inv.setItem(i, stack);
        } else {
          inv.setItem(i, null);
        }
      }
    }
    return remaining;
  } catch (e) {
    console.warn("deposit:", player?.name, amount, e);
    return amount;
  }
}

function withdraw(player, amount) {
  try {
    const inv = player.getComponent("inventory").container;
    let remaining = amount;

    for (let i = 0; i < inv.size && remaining > 0; i++) {
      const stack = inv.getItem(i);
      if (!stack) {
        const give = Math.min(remaining, 64);
        inv.setItem(i, new ItemStack(DIAMOND_ITEM_ID, give));
        remaining -= give;
      } else if (stack.typeId === DIAMOND_ITEM_ID && stack.amount < 64) {
        const give = Math.min(remaining, 64 - stack.amount);
        stack.amount += give;
        inv.setItem(i, stack);
        remaining -= give;
      }
    }
    return remaining;
  } catch (e) {
    console.warn("withdraw:", player?.name, amount, e);
    return amount;
  }
}

// ===== SLIP & PAPER
function requirePaper(player) {
  try {
    const inv = player.getComponent("inventory").container;

    for (let i = 0; i < inv.size; i++) {
      const item = inv.getItem(i);
      if (item?.typeId === "minecraft:paper" && (!item.getLore || item.getLore().length === 0)) {
        if (item.amount > 1) {
          item.amount -= 1;
          inv.setItem(i, item);
        } else {
          inv.setItem(i, null);
        }
        return true;
      }
    }

    player.sendMessage("§c[x] ไม่มีกระดาษสำหรับทำสลิป");
    return false;
  } catch (e) {
    console.warn("requirePaper:", player?.name, e);
    return false;
  }
}

function giveSlip(player, lines) {
  try {
    const slip = new ItemStack("minecraft:paper", 1);
    slip.setLore(lines);
    const leftover = player.getComponent("inventory").container.addItem(slip);
    if (leftover?.amount > 0) {
      player.dimension.spawnItem(leftover, player.location);
    }
  } catch (e) {
    console.warn("giveSlip:", player?.name, e);
  }
}

function createDepositSlip(player, amount, newBalance) {
  try {
    const safeBalance = typeof newBalance === "number" && !isNaN(newBalance) ? newBalance : getBalance(player);

    giveSlip(player, [
      "§r§eประเภท: §fฝาก",
      `§r§eผู้เล่น: §f${player.name}`,
      `§r§eจำนวน: §f${amount.toLocaleString()}`,
      `§r§eยอดคงเหลือ: §f${safeBalance.toLocaleString()}`,
      `§r§eวันที่: §f${getDateTime()}`,
    ]);
  } catch (e) {
    console.warn("createDepositSlip:", e);
  }
}

function createWithdrawSlip(player, amount, newBalance) {
  try {
    giveSlip(player, [
      "§r§eประเภท: §fถอน",
      `§r§eผู้เล่น: §f${player.name}`,
      `§r§eจำนวน: §f${amount.toLocaleString()}`,
      `§r§eยอดคงเหลือ: §f${newBalance.toLocaleString()}`,
      `§r§eวันที่: §f${getDateTime()}`,
    ]);
  } catch (e) {
    console.warn("createWithdrawSlip:", e);
  }
}

function createTransferSlip(player, targetName, amount, newBalance) {
  try {
    const safeBalance = typeof newBalance === "number" && !isNaN(newBalance) ? newBalance : getBalance(player);

    giveSlip(player, [
      "§r§eประเภท: §fโอน",
      `§r§eไปยัง: §f${targetName}`,
      `§r§eจำนวน: §f${amount.toLocaleString()}`,
      `§r§8-----------------------`,
      `§r§eผู้เล่น: §f${player.name}`,
      `§r§eยอดคงเหลือ: §f${safeBalance.toLocaleString()}`,
      `§r§eวันที่: §f${getDateTime()}`,
    ]);
  } catch (e) {
    console.warn("createTransferSlip:", e);
  }
}

// ===== CORE LOGIC
function depositDiamond(player, amount) {
  try {
    const diamonds = countDiamonds(player);
    const toDeposit = Math.min(amount, diamonds);
    if (toDeposit < 1) return 0;

    const remaining = deposit(player, toDeposit);
    const deposited = toDeposit - remaining;

    if (deposited > 0) {
      addBalance(player, deposited);

      const interestKey = getInterestKey(player);
      if (getScore(interestKey) === undefined || getScore(interestKey) === null) {
        setScore(interestKey, 0);
      }
    }
    return deposited;
  } catch (e) {
    console.warn("depositDiamond:", player?.name, amount, e);
    return 0;
  }
}

function withdrawDiamond(player, amount) {
  try {
    const balance = getBalance(player);
    if (amount < 1 || balance < amount) return 0;

    const inv = player.getComponent("inventory").container;
    let capacity = 0;
    for (let i = 0; i < inv.size; i++) {
      const stack = inv.getItem(i);
      if (!stack) capacity += 64;
      else if (stack.typeId === DIAMOND_ITEM_ID) capacity += 64 - stack.amount;
    }

    if (capacity < amount) return 0;
    setBalance(player, balance - amount);

    const interestKey = getInterestKey(player);
    const lastClaimValue = getScore(interestKey);
    if (lastClaimValue === 0 || lastClaimValue === undefined) {
      setScore(interestKey, 0);
    } else {
    }

    const leftover = withdraw(player, amount);
    if (leftover > 0) {
      setBalance(player, balance);
      return 0;
    }
    return amount;
  } catch (e) {
    console.warn("withdrawDiamond:", player?.name, amount, e);
    return 0;
  }
}

function claimInterest(player) {
  try {
    const key = getInterestKey(player);
    const balance = getBalance(player);

    if (balance <= 0) {
      const currentDateValue = getScore(key);
      if (currentDateValue === undefined || currentDateValue === null) {
        setScore(key, 0);
      }
      return 0;
    }

    const lastClaimValue = getScore(key);
    const lastClaimTime = lastClaimValue > 0 ? parseDateIntValue(lastClaimValue).getTime() : 0;
    const nextClaimTime = lastClaimTime + INTEREST_COOLDOWN_MS;

    if (Date.now() < nextClaimTime) return 0;

    const interestAmount = Math.floor(balance * INTEREST_RATE);
    addBalance(player, interestAmount);
    setScore(key, getDateIntValue(new Date()));
    return interestAmount;
  } catch (e) {
    console.warn("claimInterest:", player?.name, e);
    return 0;
  }
}

function getTransferTargets(player) {
  try {
    return world.getAllPlayers().filter((p) => p.id !== player.id);
  } catch (e) {
    console.warn("getTransferTargets:", player?.name, e);
    return [];
  }
}

function canTransfer(player, amount) {
  try {
    const balance = getBalance(player);
    if (balance < amount || amount <= 0) return false;
    return requirePaper(player);
  } catch (e) {
    console.warn("canTransfer:", player?.name, amount, e);
    return false;
  }
}

function executeTransfer(player, target, amount) {
  try {
    const senderBalanceBefore = getBalance(player);
    if (senderBalanceBefore < amount) {
      player.sendMessage("§c[x] ยอดเงินไม่เพียงพอสำหรับโอน");
      return false;
    }

    const newBalance = removeBalance(player, amount);
    addBalance(target, amount);

    createTransferSlip(player, target.name, amount, newBalance);

    player.sendMessage(`§a[Banking] §f${player.name} §aโอน: §f[${amount.toLocaleString()} Diamond]§a ให้:§f ${target.name}`);
    target.sendMessage(`§a[Banking] §f${target.name} §aได้รับ: §f[${amount.toLocaleString()} Diamond]§a จาก:§f ${player.name}`);
    return true;
  } catch (e) {
    console.warn("executeTransfer:", player?.name, "->", target?.name, amount, e);
    return false;
  }
}

async function showTransferForm(player, targets, maxAmount) {
  try {
    const form = await new ModalFormData()
      .title("Sleeplite Banking | โอนเพชร")
      .dropdown(
        "เลือกผู้รับ",
        targets.map((p) => p.name)
      )
      .slider("จำนวนเพชร", 1, maxAmount, { valueStep: 1, defaultValue: 1 })
      .show(player);

    if (!form || form.canceled) return null;

    const [index, amount] = form.formValues ?? [];
    const target = targets[index];
    if (!target) return null;

    return { target, amount };
  } catch (e) {
    console.warn("showTransferForm:", player?.name, e);
    return null;
  }
}

function getInterestStatus(player) {
  try {
    const balance = getBalance(player);
    const key = getInterestKey(player);
    const lastClaimValue = getScore(key);
    const lastClaimDate = parseDateIntValue(lastClaimValue);
    const interest = balance > 0 ? Math.floor(balance * INTEREST_RATE) : 0;

    const lastDateStr = lastClaimValue === 0 ? "ยังไม่เคยรับ" : formatDate(lastClaimDate);
    const statusText =
      balance <= 0
        ? "เงินต้น 0 ไม่มีดอกเบี้ย"
        : lastClaimValue === 0
        ? "สามารถรับดอกเบี้ยได้ (ครั้งแรก)"
        : Date.now() >= lastClaimDate.getTime() + INTEREST_COOLDOWN_MS
        ? "§aสามารถรับดอกเบี้ยได้แล้ว!§r"
        : `รออีก ${Math.ceil((lastClaimDate.getTime() + INTEREST_COOLDOWN_MS - Date.now()) / (1000 * 60 * 60 * 24))} วัน (รับได้: ${formatDate(
            new Date(lastClaimDate.getTime() + INTEREST_COOLDOWN_MS)
          )})`;

    return { balance, interest, lastDateStr, statusText };
  } catch (e) {
    console.warn("getInterestStatus:", player?.name, e);
    return { balance: 0, interest: 0, lastDateStr: "ไม่มี", statusText: "เกิดข้อผิดพลาด" };
  }
}

// ===== UI
async function showBalanceUI(player) {
  try {
    const playerName = player.name;
    const playerId = player.id;
    const balance = getBalance(player).toLocaleString();

    await new MessageFormData()
      .title("Sleeplite Banking | ยอดในธนาคาร")
      .body(
        `----------------------\n` +
          `ธนาคาร: SLEEPLITE BANKING§r\n` +
          `ชื่อ: ${playerName}\n` +
          `ไอดี: ${playerId}\n\n` +
          `ยอดเงินของคุณ ${balance} เพชร§r\n` +
          `----------------------`
      )
      .button1("ตกลง")
      .button2("ปิด")
      .show(player);
  } catch (e) {
    console.warn("[ERROR] showBalanceUI:", player?.name, e);
  }
}

async function depositDiamondUI(player) {
  try {
    const totalDiamonds = countDiamonds(player);
    if (totalDiamonds < 1) return player.sendMessage("§c[x] คุณไม่มีเพชรในกระเป๋าเพื่อฝาก");

    const form = await new ModalFormData()
      .title("Sleeplite Banking | ฝากเพชรเข้าธนาคาร")
      .slider("จำนวนเพชรที่ต้องการฝาก", 1, totalDiamonds, { valueStep: 1, defaultValue: 1 })
      .show(player);
    if (!form || form.canceled) return;

    const [amount] = form.formValues ?? [1];

    if (!requirePaper(player)) return;

    const deposited = depositDiamond(player, amount);
    if (deposited < 1) return player.sendMessage("§c[x] ฝากไม่สำเร็จ");

    const newBalance = getBalance(player);
    createDepositSlip(player, deposited, newBalance);
    player.sendMessage(`§a[/] ฝาก §f${deposited.toLocaleString()} §aเพชรเรียบร้อย`);
  } catch (e) {
    console.warn("depositDiamondUI:", player?.name, e);
    player.sendMessage("§c[x] เกิดข้อผิดพลาดในการฝากเพชร");
  }
}

async function withdrawDiamondUI(player) {
  try {
    const balance = getBalance(player);
    if (balance < 1) return player.sendMessage("§c[x] คุณไม่มีเพชรในธนาคาร");

    const max = Math.min(balance, getEmptySlots(player) * 64 + countDiamonds(player));
    if (max < 1) return player.sendMessage("§c[x] ช่องกระเป๋าไม่พอสำหรับรับเพชร");

    const form = await new ModalFormData()
      .title("Sleeplite Banking | ถอนเพชรจากธนาคาร")
      .slider("จำนวนเพชรที่ต้องการถอน", 1, max, { valueStep: 1, defaultValue: 1 })
      .show(player);
    if (!form || form.canceled) return;

    const [amount] = form.formValues ?? [1];

    if (!requirePaper(player)) return;

    const withdrawn = withdrawDiamond(player, amount);
    if (withdrawn < 1) return player.sendMessage("§c[x] ถอนไม่สำเร็จ");

    createWithdrawSlip(player, withdrawn, getBalance(player));
    player.sendMessage(`§a[/] ถอน §f${withdrawn.toLocaleString()} §aเพชรเรียบร้อย`);
  } catch (e) {
    console.warn("withdrawDiamondUI:", player?.name, e);
    player.sendMessage("§c[x] เกิดข้อผิดพลาดในการถอนเพชร");
  }
}

async function transferMoneyUI(player) {
  try {
    const targets = getTransferTargets(player);
    if (!targets.length) {
      return player.sendMessage("§c[x] ไม่มีผู้เล่นออนไลน์คนอื่น");
    }

    const balance = getBalance(player);
    if (balance < 1) {
      return player.sendMessage("§c[x] ยอดเงินไม่พอสำหรับโอน");
    }

    const result = await showTransferForm(player, targets, balance);
    if (!result) return;

    const { target, amount } = result;

    if (!canTransfer(player, amount)) {
      return player.sendMessage("§c[x] ไม่สามารถโอนได้ (เช็คยอดเงินหรือกระดาษ)");
    }

    if (!requirePaper(player)) {
      return player.sendMessage("§c[x] ไม่มีกระดาษสำหรับทำสลิป การโอนถูกยกเลิก");
    }

    executeTransfer(player, target, amount);
  } catch (e) {
    console.warn("transferMoneyUI:", player?.name, e);
    player.sendMessage("§c[x] เกิดข้อผิดพลาดในการโอนเพชร");
  }
}

async function showInterestStatusUI(player) {
  try {
    const { balance, interest, lastDateStr, statusText } = getInterestStatus(player);

    await new MessageFormData()
      .title("Sleeplite Banking | สถานะดอกเบี้ย")
      .body(
        `วันที่รับล่าสุด: ${lastDateStr}\n` +
          `สถานะ: ${statusText}\n\n` +
          `เงินต้น: ${balance.toLocaleString()} เพชร\n` +
          `ดอกเบี้ย: ${interest.toLocaleString()} เพชร (0.03%)\n` +
          `รวมหลังรับ: ${(balance + interest).toLocaleString()} เพชร`
      )
      .button1("ตกลง")
      .button2("ปิด")
      .show(player);
  } catch (e) {
    console.warn("showInterestStatusUI:", player?.name, e);
  }
}

async function showInterestClaimUI(player) {
  try {
    const amount = claimInterest(player);
    if (amount <= 0) {
      player.sendMessage("§e[ดอกเบี้ย] ยังไม่สามารถรับดอกเบี้ยได้");
      await showInterestStatusUI(player);
      return;
    }

    if (!requirePaper(player)) return player.sendMessage("§c[x] ไม่มีกระดาษสำหรับทำสลิป การรับดอกเบี้ยถูกยกเลิก");

    const newBalance = getBalance(player);
    createDepositSlip(player, amount, newBalance);
    player.sendMessage(`§a[ดอกเบี้ย] รับดอกเบี้ย §f+${amount.toLocaleString()} §aเพชรเรียบร้อย!`);
  } catch (e) {
    console.warn("showInterestClaimUI:", player?.name, e);
    player.sendMessage("§c[x] เกิดข้อผิดพลาดในการรับดอกเบี้ย");
  }
}

// ===== ADMIN UTILITIES
const isAdmin = (player) => {
  if (!player.hasTag("admin")) {
    console.warn("ADMIN ACCESS DENIED:", player.name);
    player.sendMessage("§c[x] คุณไม่มีสิทธิ์ใช้งานเมนูนี้");
    return false;
  }
  return true;
};

const getAllBankPlayers = () => {
  const bankObjective = getBankObjective();
  if (!bankObjective) return [];

  return [...bankObjective.getScores()]
    .map((s) => s.participant.displayName)
    .filter((name, i, arr) => !name.startsWith("+") && arr.indexOf(name) === i)
    .sort();
};

const getPlayerFinanceInfo = (playerName) => {
  const playerObj = world.getPlayers().find((p) => p.name === playerName);
  const { balance, interest, lastDateStr, statusText } = getInterestStatus(playerName);

  return {
    balance,
    interest,
    lastDateStr,
    statusText,
    onlineStatus: playerObj ? "§aออนไลน์" : "§cออฟไลน์",
    playerId: playerObj?.id || "§8ไม่พบ (ออฟไลน์)",
  };
};

const showAdminDropdown = async (admin, playerNames) => {
  if (!playerNames.length) {
    admin.sendMessage("§e[!] ยังไม่มีผู้เล่นในระบบธนาคาร");
    return null;
  }
  try {
    const response = await new ModalFormData().title("Admin | ดูข้อมูลการเงิน").dropdown("เลือกผู้เล่น", playerNames).show(admin);

    return response?.formValues?.[0] != null ? playerNames[response.formValues[0]] : null;
  } catch (err) {
    console.warn("ERROR: Admin Dropdown", err);
    admin.sendMessage("§c[x] เกิดข้อผิดพลาดในการแสดงฟอร์ม");
    return null;
  }
};

const displayPlayerFinance = async (admin, playerName) => {
  try {
    const info = getPlayerFinanceInfo(playerName);

    const bodyText = [
      "§7━━━━━━━━━━━━━━━━§r",
      `§eผู้เล่น: §f${playerName}`,
      `§eไอดี: §f${info.playerId}`,
      `§eสถานะ: ${info.onlineStatus}`,
      "",
      `§eยอดเงินในธนาคาร: §f${info.balance.toLocaleString()} Diamond`,
      `§eดอกเบี้ยรอรับ: §f${info.interest.toLocaleString()} Diamond`,
      `§eรับดอกเบี้ยล่าสุด: §f${info.lastDateStr}`,
      `§eสถานะดอกเบี้ย: §f${info.statusText}`,
      "§7━━━━━━━━━━━━━━━━",
    ].join("\n");

    const form = new MessageFormData().title(`ข้อมูลการเงิน: ${playerName}`).body(bodyText).button1("ปิดหน้าต่าง").button2("เลือกผู้เล่นอีกครั้ง");

    const response = await form.show(admin);
    if (!response || response.canceled) return;

    if (response.selection === 1) {
      const allPlayers = getAllBankPlayers();
      const selectedName = await showAdminDropdown(admin, allPlayers);
      if (selectedName) await displayPlayerFinance(admin, selectedName);
    }
  } catch (err) {
    console.warn("displayPlayerFinance error:", playerName, err);
    admin.sendMessage("§c[x] เกิดข้อผิดพลาดในการแสดงข้อมูล");
  }
};

const openAdminFinanceMenu = async (admin) => {
  if (!isAdmin(admin)) return;

  const playerNames = getAllBankPlayers();
  const selectedName = await showAdminDropdown(admin, playerNames);
  if (!selectedName) return;

  await displayPlayerFinance(admin, selectedName);
};

// ===== showMainMenu
async function showMainMenu(player) {
  try {
    const form = new ActionFormData()
      .title("Sleeplite Banking")
      .body("กรุณาเลือกเมนูด้านล่าง")
      .button("เช็คยอดเงิน")
      .button("ดอกเบี้ย")
      .button("โอน")
      .button("ฝาก")
      .button("ถอน");

    if (player.hasTag("admin")) {
      form.button("การเงิน");
    }

    const formResult = await form.show(player);
    if (!formResult || formResult.canceled) return;

    const menuActions = [
      showBalanceUI,
      showInterestClaimUI,
      transferMoneyUI,
      depositDiamondUI,
      withdrawDiamondUI,
      player.hasTag("admin") ? openAdminFinanceMenu : null,
    ].filter(Boolean);

    const action = menuActions[formResult.selection];
    if (action) system.run(() => action(player));
  } catch (e) {
    console.warn("showMainMenu:", player?.name, e);
    player.sendMessage("§c[x] เกิดข้อผิดพลาดในเมนูธนาคาร");
  }
}

// ===== EVENT
world.afterEvents.itemUse.subscribe((e) => {
  try {
    if (e.itemStack.typeId !== BANK_OPEN_ITEM) return;
    if (e.source instanceof Player) {
      system.run(() => showMainMenu(e.source));
    }
  } catch (e) {
    console.warn("itemUse event:", e);
  }
});

system.run(() => initializeObjective());
